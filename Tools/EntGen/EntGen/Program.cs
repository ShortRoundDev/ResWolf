using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;

using HandlebarsDotNet;

namespace EntGen
{
    class Program
    {
        static List<string> errors = new();
        static string headerText = "#pragma once\n\n";
        static string sourceText = "#include \"EntityDef.h\"\n\n";
        static void Main(string[] args)
        {

            AppendHead(
                "/* !!!! DO NOT MODIFY THIS FILE !!!!" +
                " * This file was generated by EntGen.exe. Your changes will be overridden on the next build\n" +
                " * If you want to change this file, change the relevant entity config file, or change the\n" +
                " * EntityDef.hbs template file\n" +
                " */"
            );

            AppendSource(
                "/* !!!! DO NOT MODIFY THIS FILE !!!!" +
                " * This file was generated by EntGen.exe. Your changes will be overridden on the next build\n" +
                " * If you want to change this file, change the relevant entity config file, or change the\n" +
                " * EntityDef.hbs template file\n" +
                " */"
            );

            RegisterHelpers();

            if (args.Length != 2)
            {
                AppendHead("#error EntGen.exe failed! Build didn't pass a path or template!");
                goto flush;
            }
            else if (!File.Exists(args[0]))
            {
                AppendHead("#error EntGen.exe failed! Path does not exist at [" + args[0] + "]");
                goto flush;
            }
            else if (!File.Exists(args[1] + ".h.hbs") || !File.Exists(args[1] + ".cpp.hbs"))
            {
                AppendHead("#error EntGen.exe failed! Path does not exist at [" + args[1] + "]");
                goto flush;
            }
            string text = File.ReadAllText(args[0]);
            var pairs = LoadPairs(text);

            string headerTempText = File.ReadAllText(args[1] + ".h.hbs");

            var headerTemplate = Handlebars.Compile(headerTempText);
            AppendHead(headerTemplate(new { pairs, errors }));

            string sourceTempText = File.ReadAllText(args[1] + ".cpp.hbs");

            var sourceTemplate = Handlebars.Compile(sourceTempText);
            AppendSource(sourceTemplate(new { pairs }));

        flush:
            File.WriteAllText("EntityDef.h", headerText);
            File.WriteAllText("EntityDef.cpp", sourceText);
        }

        public static List<(string Ent, int Id)> LoadPairs(string Config)
        {
            List<(string Ent, int Id)> entPairs = new();
            var SR = new StringReader(Config);
            string line = "";
            for(int lineNo = 1; ((line = SR.ReadLine()) != null); lineNo++)
            {
                if (string.IsNullOrWhiteSpace(line))
                {
                    continue;
                }
                var parts = line.Split('=');
                if (parts.Length != 2)
                {
                    Error($"Invalid ent config on line {lineNo}. Got '{line}'");
                    continue;
                }
                var trimmed = parts.Select(s => s.Trim()).ToArray();

                var ent = trimmed[0];
                if(!Int32.TryParse(trimmed[1], out int id)){
                    Error($"Invalid ID for Ent '{ent}' at line {lineNo}! Got '{trimmed[1]}'");
                    continue;
                }
                entPairs.Add((ent, id));
            }
            return entPairs;
        }

        public static void Error(string Error) {
            errors.Add(Error);
        }

        public static void AppendHead(string head)
        {
            headerText += head + "\n";
        }

        public static void AppendSource(string source)
        {
            sourceText += source + "\n";
        }

        public static void RegisterHelpers()
        {
            Handlebars.RegisterHelper("Up", (writer, context, parameters) =>
            {
                if(parameters.Count() != 1 || parameters[0] is not string s)
                {
                    return;
                }
                writer.Write(s.ToUpper());
            });
        }
    }
}
